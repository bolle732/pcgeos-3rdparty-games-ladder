/*
 ***************************************************************************
 * Copyright 2019 Andreas Bollhalder
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ***************************************************************************
 */


/*
 ***************************************************************************
 * Copyright (c) 2010-2024 by YoYu-Productions
 *
 * PROJECT:     GeoLadder
 * MODULE:      GOC code file
 * FILE:        Main\process.goc
 *
 * AUTHOR:      Andreas Bollhalder
 ***************************************************************************
 */


/*
 ***************************************************************************
 *                  COMPILER SWITCHES
 ***************************************************************************
 */
#pragma disable_message(303)


/*
 ***************************************************************************
 *                  INCLUDE FILES
 ***************************************************************************
 */

@include <stdapp.goh>

@include <ladder.goh>
@include <UI/appui.goh>

#include "initfile.h"
#include <sound.h>
#include <Ansi/ctype.h>
#include <Ansi/stdio.h>
#include <Ansi/string.h>


/*
 ***************************************************************************
 *                  EXTERNAL DECLARATIONS (see LADPALY.GOC)
 ***************************************************************************
 */

extern GLGlobals g;

extern word _pascal Random(word max);


/*
 ***************************************************************************
 *                  LOCAL DECLARATIONS
 ***************************************************************************
 */

static char ICA[] = INI_CAT_APP;
static char IKF[] = INI_KEY_FONT;
static char IKS[] = INI_KEY_STATE;
static char IKL[] = INI_KEY_LAST;

static char ICU[] = INI_CAT_UI;
static char IKP[] = INI_KEY_PRODUCT;

// Lookup table for jokes
static optr LJK[JOKS] =
{
  @MenuJoke1, @MenuJoke2, @MenuJoke3, @MenuJoke4
};
// Lookup table for score of compliments
static word LHS[CMPS] =
{
  0, 100, 200, 500, 1000, 2000, 5000
};
// Lookup table for text of compliments
static optr LHT[CMPS] =
{
  @HighCompliment1, @HighCompliment2, @HighCompliment3, @HighCompliment4, @HighCompliment5, @HighCompliment6, @HighCompliment7
};

void _pascal StopTimer(void);
static word _pascal TicksByDifficulty(word diff);


/*
 ***************************************************************************
 *                  FUNCTIONS
 ***************************************************************************
 */

/***********************************************************************
 *                  StopTimer
 ***********************************************************************
 * SYNOPSIS:        Stop a running timer and reset the global variables
 *                  of the timer.
 * CALLED BY:       Internal
 * PARAMETERS:      void ( void )
 * RETURN:          nothing
 * SIDE EFFECTS:    We do not flush the message queue which could
 *                  contain an already sent message.
 *
 * STRATEGY:        1/ Check if the global TimerHandle is not a
 *                     NullHandle.
 *                  2/ Stop the timer referenced by the global
 *                     TimerHandle.
 *                  3/ Set the global TimerHandle to a NullHandle.
 *                  4/ Set the global TimerID to 0.
 *
 * REVISION HISTORY:
 *      Name    Date          Description
 *      ----    ----          -----------
 *      boa     2011-01-18    Initial Revision
 *
 ***********************************************************************/
void _pascal StopTimer(void)
{
  if (g.ns.timerHandle != NullHandle)
  {
    TimerStop(g.ns.timerHandle, g.ns.timerId);
    g.ns.timerHandle = NullHandle;
    g.ns.timerId = 0;
  }
}

/***********************************************************************
 *                  StopAndFreeNoise
 ***********************************************************************
 * SYNOPSIS:        Stop a playing noise and reset the global variables
 *                  of the noise.
 * CALLED BY:       Internal
 * PARAMETERS:      void ( void )
 * RETURN:          nothing
 * SIDE EFFECTS:    We do not flush the message queue which could
 *                  contain an already sent message.
 *
 * STRATEGY:        1/ Check if the global SoundHandle is not a
 *                     NullHandle.
 *                  2/ Stop and free the noise referenced by the global
 *                     SoundHandle.
 *                  3/ Set the global SoundHandle to a NullHandle.
 *
 * REVISION HISTORY:
 *      Name    Date          Description
 *      ----    ----          -----------
 *      boa     2013-01-07    Initial Revision
 *
 ***********************************************************************/
void _pascal StopAndFreeNoise(void)
{
  if (g.ns.noiseHandle != NullHandle)
  {
    SoundStopMusicNote(g.ns.noiseHandle);
    SoundFreeMusicNote(g.ns.noiseHandle);
    g.ns.noiseHandle = NullHandle;
  }
}

/***********************************************************************
 *                  TicksByDifficulty
 ***********************************************************************
 * SYNOPSIS:        Calculate the ticks between two frames from the
 *                  difficulty set by the user.
 * FORMULA:         ticks = abs(diff - CFG_DIFF_MAX) + 4
 * CALLED BY:       Internal
 * PARAMETERS:      word ( word diff )
 * RETURN:          A word containing the number of ticks.
 * SIDE EFFECTS:    none
 *
 * STRATEGY:        1/ Implement the formula without FP usage.
 *
 * REVISION HISTORY:
 *      Name    Date          Description
 *      ----    ----          -----------
 *      boa     2011-01-18    Initial Revision
 *
 ***********************************************************************/
static word _pascal TicksByDifficulty(word diff)
{
  sword d;
  d = diff - CFG_DIFF_MAX;
  if (d < 0)
  {
    d = -d;
  }
  return d + 4;
}

/***********************************************************************
 *                  VerifyAndLoadFontConfig
 ***********************************************************************
 * SYNOPSIS:        Verify that the requested font size can be used
 *                  with the current video resolution and set the most
 *                  accommodating font size.
 * CALLED BY:       Internal
 * PARAMETERS:      sword ( word index )
 * RETURN:          A signed word containing font index we could set or
 *                  -1 of out of index or no font size is found.
 * SIDE EFFECTS:    none
 *
 * STRATEGY:        1/ Check index for out of range.
 *                  2/ Search the largest font by the index which can be
 *                     used with the current video resolution.
 *
 * REVISION HISTORY:
 *      Name    Date          Description
 *      ----    ----          -----------
 *      boa     2024-08-06    Initial Revision
 *
 ***********************************************************************/
static sword _pascal VerifyAndLoadFontConfig(word index)
{
  int i;
  sbyte retVal;
  GLFont font;
  MemLock(OptrToHandle(@FontConfigs));
  if (index >= ChunkArrayGetCount(@FontConfigs))
  {
    retVal = -1;
  }
  else
  {
    // XXX: Make better code!
    for (i = index; i >= 0; i--)
    {
      ChunkArrayGetElement(@FontConfigs, i, &font);
      if ((font.width * SCN_COLS < g.ns.screen.R_right) && (font.height * SCN_ROWS < g.ns.screen.R_bottom))
      {
        g.is.fontIndex = i;
        ChunkArrayGetElement(@FontConfigs, i, &g.ns.font);
        break;
      }
    }
    retVal = i;
  }
  MemUnlock(OptrToHandle(@FontConfigs));
  return retVal;
}


/*
 ***************************************************************************
 *                  CODE for LadderProcessClass
 ***************************************************************************
 */

@classdecl LadderProcessClass, neverSaved;

@extern method LadderProcessClass, MSG_LAD_DEMO_LOAD_HEAD, MSG_LAD_PLAY_LOAD_HEAD;
@extern method LadderProcessClass, MSG_LAD_DEMO_LOAD_DATA, MSG_LAD_PLAY_LOAD_DATA;
@extern method LadderProcessClass, MSG_LAD_PLAY_LOAD_SHOW;
@extern method LadderProcessClass, MSG_LAD_DEMO_INIT, MSG_LAD_PLAY_INIT;
@extern method LadderProcessClass, MSG_LAD_PLAY_READY;
@extern method LadderProcessClass, MSG_LAD_DEMO_START, MSG_LAD_PLAY_START;
@extern method LadderProcessClass, MSG_LAD_DEMO_EXEC, MSG_LAD_PLAY_EXEC;
@extern method LadderProcessClass, MSG_LAD_PLAY_HOLD;
@extern method LadderProcessClass, MSG_LAD_PLAY_FAIL;
@extern method LadderProcessClass, MSG_LAD_PLAY_DIES;
@extern method LadderProcessClass, MSG_LAD_PLAY_CLEAR;
@extern method LadderProcessClass, MSG_LAD_PLAY_HOOKA;
@extern method LadderProcessClass, MSG_LAD_PLAY_NEXT;
@extern method LadderProcessClass, MSG_LAD_EXEC_SET_FLAGS;
@extern method LadderProcessClass, MSG_LAD_FONT_CHANGE_SIZE;


/***********************************************************************
 *                  MSG_GEN_PROCESS_OPEN_APPLICATION
 *                  for LadderProcessClass
 ***********************************************************************
 * SYNOPSIS:        Setup the memory and initialize values.
 * CALLED BY:       Startup
 * PARAMETERS:      void ( AppAttachFlags attachFlags,
 *                         MemHandle launchBlock,
 *                         MemHandle extraState )
 * RETURN:          nothing
 * SUPER:           Must be called before any visible actions.
 * SIDE EFFECTS:    If the reallocation of memory for the level buffer
 *                  fails, unexpected behaviour will happen.
 *
 * STRATEGY:        1/ Set the help file name from localized chunk.
 *                  2/ Get the our version number from the system.
 *                  3/ Get the GEOS product name from the INI file.
 *                  4/ Reallocate level buffer to the full space.
 *                  5/ Allocate a MemHandle for playing noises.
 *                  6/ Load the difficulty, sound and last score from
 *                     the INI file and set the objects to display them.
 *                     If the values can't be read from the INI file,
 *                     set default values.
 *                  7/ Send message to the LadderRank object to read in
 *                     the ranking list from his file.
 *                  8/ Call super to do the default behaviour.
 *                  9/ Start the menu.
 *
 * REVISION HISTORY:
 *      Name    Date          Description
 *      ----    ----          -----------
 *      boa     2011-01-18    Initial Revision
 *
 ***********************************************************************/
@method LadderProcessClass, MSG_GEN_PROCESS_OPEN_APPLICATION
{
  static char buf[32] = "";
  word size, state;
  GenReturnParams grp;
  MemHandle mh;
  ReleaseNumber rn;
  // Set the menu as the default
  Message msg = MSG_LAD_MENU;

  // Set the help file name
  MemLock(OptrToHandle(@LadderHelpFile));
  memcpy(&buf, LMemDeref(@LadderHelpFile), LMemGetChunkSize(@LadderHelpFile));
  @call application::MSG_META_SET_HELP_FILE(buf);
  MemUnlock(OptrToHandle(@LadderHelpFile));

  // Get and set the version number
  GeodeGetInfo(GeodeGetProcessHandle(), GGIT_GEODE_RELEASE, &rn);
  MemLock(OptrToHandle(@MenuVersion));
  LMemReAlloc(@MenuVersion, 24);
  sprintf(LMemDeref(@MenuVersion), "%u.%u %u-%u", rn.RN_major, rn.RN_minor, rn.RN_change, rn.RN_engineering);
  MemUnlock(OptrToHandle(@MenuVersion));

  // Get the product name and set it as the terminal name
  // There is _NO_ null terminator!
  if (!InitFileReadStringBlock(&ICU, &IKP, &mh, 0, &size))
  {
    if (size > 23) size = 23;
    MemLock(OptrToHandle(@MenuTerminal));
    LMemReAlloc(@MenuTerminal, size + 1);
    sprintf(LMemDeref(@MenuTerminal), "%s", MemLock(mh));
   // Unlock and free the memory handle
//  MemUnlock(mh);
    MemFree(mh);
    MemUnlock(OptrToHandle(@MenuTerminal));
  }

  // Resize the level buffer
  MemLock(OptrToHandle(@GameLevelBuffer));
  LMemReAlloc(@GameLevelBuffer, LVL_M_SIZE);
  MemUnlock(OptrToHandle(@GameLevelBuffer));

  // Handle restore from state file
  if ((attachFlags & AAF_RESTORING_FROM_STATE) && extraState)
  {
    GLExtraState *state;
    // Get the extra state
    state = (GLExtraState *) MemLock(extraState);
    // Restore the global state
    g.ss = state->saveState;
    // Restore execution state
    switch (g.ss.executionState)
    {
    case EXE_S_HELP:
      msg = MSG_LAD_HELP;
      break;
    case EXE_S_PLAY:
      // Restore the level buffer
      MemLock(OptrToHandle(@GameLevelBuffer));
      memcpy(LMemDeref(@GameLevelBuffer), state->buffer, LVL_M_SIZE);
      MemUnlock(OptrToHandle(@GameLevelBuffer));
      // Set the message where we leaved the game play
      msg = g.ss.restorePoint;
//    break;
    }
    // Unlock the extra state
    MemUnlock(extraState);
  }

  // Get the font size from the INI file
  if (InitFileReadInteger(&ICA, &IKF, &g.is.fontIndex))
  {
    // No entry found, set defaults
    g.is.fontIndex = 1;
  }
  // Get the difficulty and sound state from the INI file
  if (InitFileReadInteger(&ICA, &IKS, &state))
  {
    // No entry found, set defaults
    g.is.diff = 1;
    g.is.sound = CFG_SND_OFF;
  }
  else
  {
    // Get the difficulty from the high byte
    g.is.diff = state >> 8;
    // Get the sound from the low byte
    g.is.sound = state & 0x0F;
  }
  // Get the last score from the INI file
  if (InitFileReadInteger(&ICA, &IKL, &g.is.lastScore))
  {
    // No entry found, set defaults
    g.is.lastScore = 0;
  }

  // Get the video resolution
  //  @call application::MSG_VIS_GET_BOUNDS(&g.ns.screen);
  @call application::MSG_GEN_GUP_QUERY(&grp, GUQT_FIELD);
  WinGetWinScreenBounds(grp.GRP_bp, &g.ns.screen);

  // Set defaults to no state globals
  // XXX: Check and set colors according the available ones (monochrome)
  g.ns.gstateHandle = NullHandle;
  g.ns.textColor = C_LIGHT_GREEN;
  g.ns.areaColor = C_BLACK;

  // Warn user if current video resolution is too small
  // No MemLock / MemUnlock needed as the function does it for us
  if (VerifyAndLoadFontConfig(g.is.fontIndex) == -1)
  {
    UserStandardDialogOptr(
      NullOptr, NullOptr, NullOptr, NullOptr,
      @LadderWarnVideoTooSmall,
      (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET) | (CDT_NOTIFICATION << CDBF_DIALOG_TYPE_OFFSET)
    );
    msg = MSG_META_QUIT;
  }
  else
  {
    // Set fixed size hint
    @send LadderView::MSG_GEN_SET_FIXED_SIZE(
      VUM_DELAYED_VIA_APP_QUEUE, 0, SCN_ROWS * g.ns.font.height + 2, SCN_COLS * g.ns.font.width
    );
    // XXX: Research why primary is not resized when starting from state and video resolution has changed
    // Resize primary window
    @send LadderPrimary::MSG_GEN_SET_WIN_SIZE(
      GET_MM_AND_TYPE(VUM_DELAYED_VIA_APP_QUEUE, WST_AS_DESIRED), 0, 0
    );
    // Set the difficulty
    @send LadderMenuDiff::MSG_VAL_SET_VALUE(g.is.diff);
    // Set the sound
    if (g.is.sound == CFG_SND_ON)
    {
      @send LadderMenuSound::MSG_TXT_SET_TEXT(@MenuSoundOn);
    }
    // Set the last score
    @send LadderMenuLastScore::MSG_VAL_SET_VALUE(g.is.lastScore);
    // Load the scores from the file
    @send LadderMenuRank::MSG_RNK_LOAD();
  }

  // Allocate a memory handle for the noise
  SoundAllocMusicNote(0, 0, 0, 0, 0, 0, &g.ns.noiseHandle);

  // Let's start the menu or continue where we left the application
  @send process::{MSG_LAD_PROTO} msg();
  // Do super
  @callsuper();
}

/***********************************************************************
 *                  MSG_GEN_PROCESS_CLOSE_APPLICATION
 *                  for LadderProcessClass
 ***********************************************************************
 * SYNOPSIS:        Stop and release self allocated resources, save
 *                  state values.
 * CALLED BY:       Shutdown
 * PARAMETERS:      MemHandle ( void )
 * RETURN:          NullHandle
 * SUPER:           Must be called after releasing any self allocated
 *                  resources.
 * SIDE EFFECTS:    none
 *
 * STRATEGY:        1/ Stop any potentially running timer.
 *                  2/ Stop and free the MemHandle for playing noises.
 *                  3/ Save the difficulty, sound and last score to the
 *                     INI file.
 *                  4/ Call super to do the default behaviour.
 *                  5/ Return a NullHandle to indicate we don't have
 *                     any extra state.
 *
 * REVISION HISTORY:
 *      Name    Date          Description
 *      ----    ----          -----------
 *      boa     2011-01-18    Initial Revision
 *
 ***********************************************************************/
@method LadderProcessClass, MSG_GEN_PROCESS_CLOSE_APPLICATION
{
  GLExtraState *state;
  MemHandle mh;
  // Stop the current timer
  StopTimer();
  // Stop the noise
  StopAndFreeNoise();
  // Write the font size to the INI file
  InitFileWriteInteger(&ICA, &IKF, g.is.fontIndex);
  // Write the state to the INI file
  InitFileWriteInteger(&ICA, &IKS, (g.is.diff << 8) | (g.is.sound & 0x0F));
  // Write the last score to the INI file
  InitFileWriteInteger(&ICA, &IKL, g.is.lastScore);
  // Do super
  @callsuper();
  // Set saved to state
  g.ss.executionFlags |= EXE_M_RST;
  // Allocate memory for our struct to save the extra state
  mh = MemAlloc(sizeof(GLExtraState), HF_DYNAMIC | HF_SHARABLE, 0);
  state = (GLExtraState *) MemLock(mh);
  // Save the global state
  state->saveState = g.ss;
  // Save the game objects and the level buffer if we are in a play
  if (g.ss.executionState == EXE_S_PLAY)
  {
    // Set the objects dirty so they get saved into the state
    ObjMarkDirty(@LadderView);
    ObjMarkDirty(@LadderGameActors);
    ObjMarkDirty(@LadderGameLads);
    ObjMarkDirty(@LadderGameRound);
    ObjMarkDirty(@LadderGameScore);
    ObjMarkDirty(@LadderGameTime);
    // Save the level buffer
    MemLock(OptrToHandle(@GameLevelBuffer));
    memcpy(state->buffer, LMemDeref(@GameLevelBuffer), LVL_M_SIZE);
    MemUnlock(OptrToHandle(@GameLevelBuffer));
  }
  // Unlock memory of extra state
  MemUnlock(mh);
  // Return our extra state
  return mh;
 }

/***********************************************************************
 *                  MSG_LAD_MENU
 *                  for LadderProcessClass
 ***********************************************************************
 * SYNOPSIS:        Initialize and load the menu screen.
 * CALLED BY:       Startup or when returning from help or play.
 * PARAMETERS:      void (  )
 * RETURN:          nothing
 * SIDE EFFECTS:    none
 *
 * STRATEGY:        1/ Set the global states.
 *                  2/ Clear the info line.
 *                  3/ Set the content.
 *                  4/ Disarm the jokes or demo.
 *
 * REVISION HISTORY:
 *      Name    Date          Description
 *      ----    ----          -----------
 *      boa     2011-01-18    Initial Revision
 *
 ***********************************************************************/
@method LadderProcessClass, MSG_LAD_MENU
{
  // Set the input state for the handling of key presses
  g.ss.inputState = INP_S_MENU;
  // Set the execution state
  g.ss.executionState = EXE_S_MENU;
  // Reset the control state
  g.ns.menuCount = 0;
  // Clear the text in the info line
  @send LadderMenuInfo::MSG_TXT_UPDATE_TEXT(NullOptr);
  // Show the menu screen
  @send LadderView::MSG_GEN_VIEW_SET_CONTENT(@LadderMenu);
  // Handle window minimized
  if (g.ss.executionFlags & EXE_M_MIN)
  {
    // Arm the jokes or demo
    @send oself::MSG_LAD_MENU_STOP();
  }
  else
  {
    // Disarm the jokes or demo
    @send oself::MSG_LAD_MENU_AUTO();
  }
}

/***********************************************************************
 *                  MSG_LAD_MENU_DIFF, MSG_LAD_MENU_SOUND
 *                  for LadderProcessClass
 ***********************************************************************
 * SYNOPSIS:        Change the difficulty or enable / disable the sound.
 * CALLED BY:       (a) MSG_LAD_MENU_DIFF:
 *                      User by pressing the key 'd' in the menu.
 *                  (b) MSG_LAD_MENU_SOUND:
 *                      User by pressing the key 's' in the menu.
 * PARAMETERS:      void (  )
 * RETURN:          nothing
 * SIDE EFFECTS:    none
 *
 * STRATEGY:        1/ Stop the jokes or demo.
 *                  2/ (a) MSG_LAD_MENU_DIFF:
 *                         Increase the difficulty. If we are over the
 *                         maximum difficulty, set it to the minimum.
 *                         Update the screen.
 *                  3/ (b) MSG_LAD_MENU_SOUND:
 *                         Enable or disable the sound.
 *                         Update the screen.
 *                  4/ Disarm the jokes or demo.
 *
 * REVISION HISTORY:
 *      Name    Date          Description
 *      ----    ----          -----------
 *      boa     2011-01-18    Initial Revision
 *
 ***********************************************************************/
@method LadderProcessClass, MSG_LAD_MENU_DIFF,
                            MSG_LAD_MENU_SOUND
{
  // Stop the jokes od demo
  @send process::MSG_LAD_MENU_STOP();
  // Handle message type
  switch (message)
  {
  case MSG_LAD_MENU_DIFF:
    // Increase the difficulty
    g.is.diff++;
    // On overflow set it to the minimum
    if (g.is.diff > CFG_DIFF_MAX)
    {
      g.is.diff = CFG_DIFF_MIN;
    }
    // Update the value on screen
    @send LadderMenuDiff::MSG_VAL_UPDATE_VALUE(g.is.diff);
    break;
  case MSG_LAD_MENU_SOUND:
    // Switch the sound state
    if (g.is.sound == CFG_SND_OFF)
    {
      // Set the sound state
      g.is.sound = CFG_SND_ON;
      // Update the text on screen
      @send LadderMenuSound::MSG_TXT_UPDATE_TEXT(@MenuSoundOn);
    }
    else  // CFG_SND_ON
    {
      // Set the sound state
      g.is.sound = CFG_SND_OFF;
      // Update the text on screen
      @send LadderMenuSound::MSG_TXT_UPDATE_TEXT(@MenuSoundOff);
    }
//  break;
  }
  // Disarm the jokes or demo
  @send process::MSG_LAD_MENU_AUTO();
}

/***********************************************************************
 *                  MSG_LAD_MENU_EXIT
 *                  for LadderProcessClass
 ***********************************************************************
 * SYNOPSIS:        Close the application.
 * CALLED BY:       User by pressing the key 'e' in the menu.
 * PARAMETERS:      void (  )
 * RETURN:          nothing
 * SIDE EFFECTS:    none
 *
 * STRATEGY:        1/ Stop any running timer.
 *                  2/ Set the input state.
 *                  3/ Set the text in the info line.
 *                  4/ Use a timer to send MSG_META_QUIT to the
 *                     application.
 *
 * REVISION HISTORY:
 *      Name    Date          Description
 *      ----    ----          -----------
 *      boa     2011-01-18    Initial Revision
 *
 ***********************************************************************/
@method LadderProcessClass, MSG_LAD_MENU_EXIT
{
  // Stop the timer
  StopTimer();
  // Set the input state for the handling of key presses
  g.ss.inputState = INP_S_NONE;
  // Set the execution state
  g.ss.executionState = EXE_S_NONE;
  // Update the info line with the exit text
  @send LadderMenuInfo::MSG_TXT_UPDATE_TEXT(@MenuExit);
  // Start the timer for the exit
  TimerStart(TIMER_EVENT_ONE_SHOT, @LadderApplication, DLY_T_EXIT, MSG_META_QUIT, 0, &g.ns.timerId);
}

/***********************************************************************
 *                  MSG_LAD_MENU_AUTO
 *                  for LadderProcessClass
 ***********************************************************************
 * SYNOPSIS:        Show a random message in the info line or start the
 *                  demo game.
 * CALLED BY:       Internal or by our self
 * PARAMETERS:      void (  )
 * RETURN:          nothing
 * SIDE EFFECTS:    none
 *
 * STRATEGY:        1/ Depending on the global state, show a random
 *                     message in the info line, clear it or start
 *                     the demo.
 *                     When called the first time, we wait a longer
 *                     time.
 *                  2/ Use a timer to call our self.
 *
 * REVISION HISTORY:
 *      Name    Date          Description
 *      ----    ----          -----------
 *      boa     2011-01-18    Initial Revision
 *
 ***********************************************************************/
@method LadderProcessClass, MSG_LAD_MENU_AUTO
{
  word d;
  optr o;
  // Check for not first time and demo time
  if (g.ns.menuCount != 0 && (g.ns.menuCount % 8 == 0))
  {
    // Reset control state
    g.ns.menuCount = 0;
    // Run the demo
    @send oself::MSG_LAD_DEMO();
  }
  // Handle joke
  else
  {
    // Set default delay
    d = DLY_T_MENU;
    // Set emtpy text
    o = NullOptr;
    // Check for not first time
    if (g.ns.menuCount != 0)
    {
      // Calculate the delay
      d = DLY_T_MENU_MIN + Random(DLY_T_MENU_RND);
      // Check show time
      if (g.ns.menuCount % 2 == 0)
      {
        // Set the text of the joke
        o = LJK[Random(JOKS)];
      }
    }
    // Increase control state
    g.ns.menuCount++;
    // Set the text in the info line
    @send LadderMenuInfo::MSG_TXT_UPDATE_TEXT(o);
    // Start the timer
    g.ns.timerHandle = TimerStart(TIMER_EVENT_ONE_SHOT, oself, d, message, 0, &g.ns.timerId);
  }
}

/***********************************************************************
 *                  MSG_LAD_MENU_STOP
 *                  for LadderProcessClass
 ***********************************************************************
 * SYNOPSIS:        Stop the jokes or demo.
 * CALLED BY:       Internal
 * PARAMETERS:      void (  )
 * RETURN:          nothing
 * SIDE EFFECTS:    none
 *
 * STRATEGY:        1/ Stop any potentially running timer.
 *                  2/ Reset the control state.
 *                  3/ Clear the info line.
 *
 * REVISION HISTORY:
 *      Name    Date          Description
 *      ----    ----          -----------
 *      boa     2011-01-18    Initial Revision
 *
 ***********************************************************************/
@method LadderProcessClass, MSG_LAD_MENU_STOP
{
  // Stop the timer
  StopTimer();
  // Reset the control state
  g.ns.menuCount = 0;
  // Clear the text in the info line
  @send LadderMenuInfo::MSG_TXT_UPDATE_TEXT(NullOptr);
}

/***********************************************************************
 *                  MSG_LAD_HELP
 *                  for LadderProcessClass
 ***********************************************************************
 * SYNOPSIS:        Load the instruction screen.
 * CALLED BY:       User by pressing the key 'i' in the menu.
 * PARAMETERS:      void (  )
 * RETURN:          nothing
 * SIDE EFFECTS:    none
 *
 * STRATEGY:        1/ Stop any potentially running timer.
 *                  2/ Set the input state.
 *                  3/ Set the content.
 *
 * REVISION HISTORY:
 *      Name    Date          Description
 *      ----    ----          -----------
 *      boa     2011-01-18    Initial Revision
 *
 ***********************************************************************/
@method LadderProcessClass, MSG_LAD_HELP
{
  // Stop the timer
  StopTimer();
  // Set the input state for the handling of key presses
  g.ss.inputState = INP_S_HELP;
  // Set the execution state
  g.ss.executionState = EXE_S_HELP;
  // Show the help screen
  @send LadderView::MSG_GEN_VIEW_SET_CONTENT(@LadderHelp);
  // Set the text of the info line
  @send LadderInfo::MSG_TXT_UPDATE_TEXT(@HelpInfo);
}

/***********************************************************************
 *                  MSG_LAD_DEMO, MSG_LAD_PLAY
 *                  for LadderProcessClass
 ***********************************************************************
 * SYNOPSIS:        Start the demo or a new game.
 * CALLED BY:       (a) MSG_LAD_DEMO:
 *                      from MSG_LAD_MENU_AUTO
 *                  (b) MSG_LAD_PLAY:
 *                      User by pressing the key 'p' in the menu.
 * PARAMETERS:      void (  )
 * RETURN:          nothing
 * SIDE EFFECTS:    none
 *
 * STRATEGY:        1/ Stop any potentially running timer.
 *                  2/ Reset the input state.
 *                  3/ Initialize the global variabels.
 *                  4/ Start loading the level info.
 *
 * REVISION HISTORY:
 *      Name    Date          Description
 *      ----    ----          -----------
 *      boa     2011-01-18    Initial Revision
 *
 ***********************************************************************/
@method LadderProcessClass, MSG_LAD_DEMO,
                            MSG_LAD_PLAY
{
  // Our demo
  GLDemo d;
  // Stop the timer
  StopTimer();
  // Initialize the game
  g.ss.game.lads = LAD_D_LIVES;
  g.ss.game.score = 0;
  g.ss.game.delay = TicksByDifficulty(g.is.diff);
  // Handle message type
  switch (message)
  {
  case MSG_LAD_DEMO:
    // Set the input state for the handling of key presses
    g.ss.inputState = INP_S_DEMO;
    // Set the execution state
    g.ss.executionState = EXE_S_DEMO;
    // Lock the game demos
    MemLock(OptrToHandle(@GameDemos));
    // Get the game demo
    ChunkArrayGetElement(@GameDemos, Random(ChunkArrayGetCount(@GameDemos)), &d);
    // Unlock the game demos
    MemUnlock(OptrToHandle(@GameDemos));
    // Set the round, level and moves
    g.ss.game.round = d.round;
    g.ss.game.level = d.level;
    g.ns.moves = d.moves;
    // Start the demo level
    @send oself::MSG_LAD_DEMO_LOAD_HEAD();
    break;
  case MSG_LAD_PLAY:
    // Set the input state for the handling of key presses
    g.ss.inputState = INP_S_PLAY;
    // Set the execution state
    g.ss.executionState = EXE_S_PLAY;
    // Initialize the round and level
    g.ss.game.round = 1; // 1, 2, 5, 9, 14, 20, 27
    g.ss.game.level = 1; // 1, 2, 3, 4, 5, 6, 7
    // Start the first level
    g.ss.restorePoint = MSG_LAD_PLAY_LOAD_HEAD;
    @send oself::MSG_LAD_PLAY_LOAD_HEAD();
//  break;
  }
}

/***********************************************************************
 *                  MSG_LAD_DEMO_STOP, MSG_LAD_PLAY_STOP
 *                  for LadderProcessClass
 ***********************************************************************
 * SYNOPSIS:        Abort the demo or a game.
 * CALLED BY:       (a) MSG_LAD_DEMO_STOP:
 *                      from MSG_LAD_DEMO_EXEC or user by pressing the
 *                      kex 'ESC' during the demo
 *                  (b) MSG_LAD_PLAY_STOP:
 *                      User by pressing the key 'ESC' during a game or
 *                      when returning from a finished game.
 * PARAMETERS:      void (  )
 * RETURN:          nothing
 * SIDE EFFECTS:    none
 *
 * STRATEGY:        1/ Stop any potentially running timer.
 *                  2/ Update the last score.
 *                  3/ Load the menu screen.
 *
 * REVISION HISTORY:
 *      Name    Date          Description
 *      ----    ----          -----------
 *      boa     2011-01-18    Initial Revision
 *
 ***********************************************************************/
@method LadderProcessClass, MSG_LAD_DEMO_STOP,
                            MSG_LAD_PLAY_STOP
{
  // Stop the game timer
  StopTimer();
  // Set the input state for the handling of key presses
  g.ss.inputState = INP_S_NONE;
  // Handle message type
  if (message == MSG_LAD_PLAY_STOP)
  {
    // Update last score
    g.is.lastScore = g.ss.game.score;
    @send LadderMenuLastScore::MSG_VAL_SET_VALUE(g.is.lastScore);
    // Reset the image of the mouse cursor / pointer
    @call LadderView::MSG_GEN_VIEW_SET_PTR_IMAGE(NullOptr, PIL_WINDOW);
  }
  // Return to main menu
  @send oself::MSG_LAD_MENU();
}

/***********************************************************************
 *                  MSG_LAD_PLAY_DONE
 *                  for LadderProcessClass
 ***********************************************************************
 * SYNOPSIS:        The user finished the last level.
 * CALLED BY:       Internal
 * PARAMETERS:      void (  )
 * RETURN:          nothing
 * SIDE EFFECTS:    none
 *
 * STRATEGY:        1/ Set the input state.
 *                  2/ Load the game end screen.
 *
 * REVISION HISTORY:
 *      Name    Date          Description
 *      ----    ----          -----------
 *      boa     2011-01-18    Initial Revision
 *
 ***********************************************************************/
@method LadderProcessClass, MSG_LAD_PLAY_DONE
{
  // Set the input state for the handling of key presses
  g.ss.inputState = INP_S_DONE;
  // Show the game done screen
  @send LadderView::MSG_GEN_VIEW_SET_CONTENT(@LadderDone);
  // Reset the image of the mouse cursor / pointer
  @call LadderView::MSG_GEN_VIEW_SET_PTR_IMAGE(NullOptr, PIL_WINDOW);
  // Set the text of the info line
  @send LadderInfo::MSG_TXT_UPDATE_TEXT(@DoneInfo);
}

/***********************************************************************
 *                  MSG_LAD_PLAY_OVER
 *                  for LadderProcessClass
 ***********************************************************************
 * SYNOPSIS:        The user lost the game.
 * CALLED BY:       Internal
 * PARAMETERS:      void (  )
 * RETURN:          nothing
 * SIDE EFFECTS:    none
 *
 * STRATEGY:        1/ Set the input state.
 *                  2/ Load the game over screen.
 *
 * REVISION HISTORY:
 *      Name    Date          Description
 *      ----    ----          -----------
 *      boa     2011-01-18    Initial Revision
 *
 ***********************************************************************/
@method LadderProcessClass, MSG_LAD_PLAY_OVER
{
  // Set the input state for the handling of key presses
  g.ss.inputState = INP_S_OVER;
  // Show the game over screen
  @send LadderView::MSG_GEN_VIEW_SET_CONTENT(@LadderOver);
  // Reset the image of the mouse cursor / pointer
  @call LadderView::MSG_GEN_VIEW_SET_PTR_IMAGE(NullOptr, PIL_WINDOW);
  // Set the text of the info line
  @send LadderInfo::MSG_TXT_UPDATE_TEXT(@OverInfo);
}

/***********************************************************************
 *                  MSG_LAD_PLAY_HIGH
 *                  for LadderProcessClass
 ***********************************************************************
 * SYNOPSIS:        We have a new high score.
 * CALLED BY:       Internal
 * PARAMETERS:      void (  )
 * RETURN:          nothing
 * SIDE EFFECTS:    none
 *
 * STRATEGY:        1/ Set the input state.
 *                  2/ Reset the input which reads the name.
 *                  3/ Clear the info line.
 *                  4/ Show the compliment for the score.
 *                  5/ Load the high score screen.
 *
 * REVISION HISTORY:
 *      Name    Date          Description
 *      ----    ----          -----------
 *      boa     2011-01-18    Initial Revision
 *
 ***********************************************************************/
@method LadderProcessClass, MSG_LAD_PLAY_HIGH
{
  word i;
  // Set the input state for the handling of key presses
  g.ss.inputState = INP_S_HIGH;
  // Reset the input
  @send LadderHighName::MSG_INP_RESET();
  // Clear the info line
  @send LadderInfo::MSG_TXT_SET_TEXT(NullOptr);
  // Find the compliment message for the score
  for (i = CMPS; i > 0; i--)
  {
    if (g.ss.game.score >= LHS[i - 1])
    {
      // Set the text of the compliment
      @send LadderHighCompliment::MSG_TXT_SET_TEXT(LHT[i - 1]);
      break;
    }
  }
  // Show the high score screen
  @send LadderView::MSG_GEN_VIEW_SET_CONTENT(@LadderHigh);
  // Set the text of the info line
  @send LadderInfo::MSG_TXT_UPDATE_TEXT(@HighInfo);
}

/***********************************************************************
 *                  MSG_LAD_PLAY_SAVE
 *                  for LadderProcessClass
 ***********************************************************************
 * SYNOPSIS:        Save the high score.
 * CALLED BY:       User by pressing the key 'ENTER' in the high score.
 * PARAMETERS:      void (  )
 * RETURN:          nothing
 * SIDE EFFECTS:    none
 *
 * STRATEGY:        1/ Update the info line.
 *                  2/ Copy the name from the input und update the
 *                     ranking list.
 *                  3/ Start a timer to return to the menu.
 *
 * REVISION HISTORY:
 *      Name    Date          Description
 *      ----    ----          -----------
 *      boa     2011-01-18    Initial Revision
 *
 ***********************************************************************/
@method LadderProcessClass, MSG_LAD_PLAY_SAVE
{
  static char lhs[RNK_NAME_LEN];
  // Set the text of the info line
  @send LadderInfo::MSG_TXT_UPDATE_TEXT(@HighSave);
  // Get the name from the imput
  @call LadderHighName::MSG_INP_GET_INPUT(&lhs);
  // Add the rank to the ranks
  @call LadderMenuRank::MSG_RNK_SAVE_RANK(g.ss.game.score, &lhs);
  // Start the timer to quit to main menu
  g.ns.timerHandle = TimerStart(TIMER_EVENT_ONE_SHOT, oself, DLY_T_SAVE, MSG_LAD_PLAY_STOP, 0, &g.ns.timerId);
}

/***********************************************************************
 *                  MSG_LAD_EXEC_SET_FLAGS
 *                  for LadderProcessClass
 ***********************************************************************
 * SYNOPSIS:        Handle window changes minimized and focus.

 * CALLED BY:       Internal by intercepted messages:
 *                  MSG_GEN_DISPLAY_SET_MINIMIZED
 *                  MSG_GEN_DISPLAY_SET_NOT_MINIMIZED
 *                  MSG_META_LOST_FOCUS_EXCL
 *                  MSG_META_GAINED_FOCUS_EXCL
 * PARAMETERS:      void ( byte state )
 * RETURN:          nothing
 * SIDE EFFECTS:    none
 *
 * STRATEGY:        1/ Update the global variable.
 *                  2/ Start or stop the menu if applicable.
 *
 * REVISION HISTORY:
 *      Name    Date          Description
 *      ----    ----          -----------
 *      boa     2024-07-15    Initial Revision
 *
 ***********************************************************************/
@method LadderProcessClass, MSG_LAD_EXEC_SET_FLAGS
{
  // Update the global window state
  switch (state)
  {
  case EXE_F_NORM:
    g.ss.executionFlags &= ~EXE_M_MIN;  // Clear bit 0
    break;
  case EXE_F_MINI:
    g.ss.executionFlags |= EXE_M_MIN;  // Set bit 0
    break;
  case EXE_F_GAIN:
    g.ss.executionFlags &= ~EXE_M_FOC;  // Clear bit 1
    break;
  case EXE_F_LOST:
    g.ss.executionFlags |= EXE_M_FOC;  // Set bit 1
//  break;
  }
  // Handle menu here
  if (g.ss.executionState == EXE_S_MENU)
  {
    switch (state)
    {
    case EXE_F_NORM:
      @send oself::MSG_LAD_MENU_AUTO();
      break;
    case EXE_F_MINI:
      @send oself::MSG_LAD_MENU_STOP();
//    break;
    }
  }
}

/***********************************************************************
 *                  MSG_LAD_FONT_CHANGE_SIZE
 *                  for LadderProcessClass
 ***********************************************************************
 * SYNOPSIS:        Handle font size changes.

 * CALLED BY:       Internal by intercepted messages:
 *                  MSG_META_KBD_CHAR
 * PARAMETERS:      void ( byte command )
 * RETURN:          nothing
 * SIDE EFFECTS:    none
 *
 * STRATEGY:        1/ Verify if font can changed.
 *                  2/ Send messages to redraw view and primary.
 *
 * REVISION HISTORY:
 *      Name    Date          Description
 *      ----    ----          -----------
 *      boa     2024-08-02    Initial Revision
 *
 ***********************************************************************/
@method LadderProcessClass, MSG_LAD_FONT_CHANGE_SIZE
{
  word cur = g.is.fontIndex;
  sword ret;
  // 
  switch (command)
  {
  case FNT_S_INC:
    ret = VerifyAndLoadFontConfig(cur + 1);
    break;
  case FNT_S_DEC:
    ret = VerifyAndLoadFontConfig(cur - 1);
//  break;
  }
  // Update only if we could change font
  if ((ret != -1) && (ret != cur))
  {
    // XXX: Update GState with new font
    // ...

    // Set fixed size hint
    @send LadderView::MSG_GEN_SET_FIXED_SIZE(
      VUM_DELAYED_VIA_APP_QUEUE, 0, SCN_ROWS * g.ns.font.height + 2, SCN_COLS * g.ns.font.width
    );

    // Resize primary window
    @send LadderPrimary::MSG_GEN_SET_WIN_SIZE(
      GET_MM_AND_TYPE(VUM_DELAYED_VIA_APP_QUEUE, WST_AS_DESIRED), 0, 0
    );
  }
}

/*
 ***************************************************************************
 *                  CODE for LadderApplicationClass
 ***************************************************************************
 */

@classdecl LadderApplicationClass;

/***********************************************************************
 *                  MSG_META_KBD_CHAR
 *                  for LadderApplicationClass
 ***********************************************************************
 * SYNOPSIS:        Handle key presses sent to our application object.
 * CALLED BY:       Internal
 * PARAMETERS:      void ( word character,
 *                         word flags,
 *                         word state )
 * RETURN:          nothing
 * SIDE EFFECTS:    none
 *
 * STRATEGY:        1/ Check if we have a key press and not a release.
 *                  2/ Handle the escape key globaly.
 *                  3/ Handle the other keys depending the application
 *                     state.
 *                  4/ If the key press has not been handled, put it
 *                     upward.
 *
 * REVISION HISTORY:
 *      Name    Date          Description
 *      ----    ----          -----------
 *      boa     2011-01-18    Initial Revision
 *
 ***********************************************************************/
@method LadderApplicationClass, MSG_META_KBD_CHAR
{
  Message msg;
  // Handle key presses during dedicated input states
  if (!(flags & CF_RELEASE) && (g.ss.inputState != INP_S_NONE) && !(g.ss.executionFlags & EXE_M_MIN))
  {
    // Set the default message to nothing
    msg = NULL;
    // Handle escape key
    if (character == 0xFF1B)
    {
      switch (g.ss.inputState)
      {
      case INP_S_DEMO:
        // Stop demo
        msg = MSG_LAD_DEMO_STOP;
        break;
      case INP_S_PLAY:
      case INP_S_EXEC:
        // Stop play
        g.ss.restorePoint = MSG_LAD_PLAY_STOP;
        msg = MSG_LAD_PLAY_STOP;
        break;
      default:
        // Return to menu
        msg = MSG_LAD_MENU;
//      break;
      }
    }
    // Handle change font size
    if ((flags >> 8) & (SS_LCTRL | SS_RCTRL))
    {
      switch (tolower(character))
      {
      case C_ONE:
        @send process::MSG_LAD_FONT_CHANGE_SIZE(FNT_S_DEC);
        return;
      case C_TWO:
        @send process::MSG_LAD_FONT_CHANGE_SIZE(FNT_S_INC);
        return;
      }
    }
    // Handle the keys according the application states
    switch (g.ss.inputState)
    {
    case INP_S_EXEC:
      // Handle the key press
      switch (character)
      {
      // Key 'Arrow Up'
      case 0xFF90:
        g.ss.lad.ndir = DIR_N;
        return;
      // Key 'Arrow Right'
      case 0xFF92:
        g.ss.lad.ndir = DIR_E;
        return;
      // Key 'Arrow Down'
      case 0xFF91:
        g.ss.lad.ndir = DIR_S;
        return;
      // Key 'Arrow Left'
      case 0xFF93:
        g.ss.lad.ndir = DIR_W;
        return;
      case C_SPACE:
        g.ss.lad.njump = L_TRUE;
        return;
      case C_SMALL_P:
      case C_CAP_P:
        g.ss.restorePoint = MSG_LAD_PLAY_HOLD;
        msg = MSG_LAD_PLAY_HOLD;
        break;
      // Any other key
      default:
        // Check for printable character
        if ((character < 255) && isprint(character))
        {
          g.ss.lad.ndir = DIR_NONE;
          return;
        }
//      break;
      }
      break;
    case INP_S_MENU:
      // Handle the key press
      switch (tolower(character))
      {
      case C_SMALL_D:
        msg = MSG_LAD_MENU_DIFF;
        break;
      case C_SMALL_S:
        msg = MSG_LAD_MENU_SOUND;
        break;
      case C_SMALL_P:
        msg = MSG_LAD_PLAY;
        break;
      case C_SMALL_I:
        msg = MSG_LAD_HELP;
        break;
      case C_SMALL_E:
        msg = MSG_LAD_MENU_EXIT;
//      break;
      }
      break;
    case INP_S_HOLD:
      // Key 'Enter'
      if (character == 0xFF0D)
      {
        g.ss.restorePoint = MSG_LAD_PLAY_READY;
        msg = MSG_LAD_PLAY_READY;
      }
      break;
    case INP_S_HIGH:
      // Handle the key press
      switch (character)
      {
      // Key 'Enter'
      case 0xFF0D:
        g.ss.restorePoint = MSG_LAD_PLAY_SAVE;
        msg = MSG_LAD_PLAY_SAVE;
        break;
      // Key 'Backspace'
      case 0xFF08:
      case C_DELETE:
        @send LadderHighName::MSG_INP_DEL_CHAR();
        return;
      default:
        // Check for printable character
        if ((character < 255) && isprint(character))
        {
          @send LadderHighName::MSG_INP_ADD_CHAR(character);
          return;
        }
//      break;
      }
      break;
    case INP_S_DONE:
    case INP_S_OVER:
      // Key 'Enter'
      if (character == 0xFF0D)
      {
        // Check for new high score
        if (@call LadderMenuRank::MSG_RNK_IS_NEW_RANK(g.ss.game.score) == L_TRUE)
        {
          g.ss.restorePoint = MSG_LAD_PLAY_HIGH;
          msg = MSG_LAD_PLAY_HIGH;
        }
        else
        {
          g.ss.restorePoint = MSG_LAD_PLAY_STOP;
          msg = MSG_LAD_PLAY_STOP;
        }
      }
//    break;
    }
    // Send the message
    if (msg != NULL)
    {
      @send process::{MSG_LAD_PROTO} msg();
      return;
    }
  }
  // Not handled, put the key press upstream
//  @send oself::MSG_META_FUP_KBD_CHAR(character, flags, state);
  @callsuper();
}

/***********************************************************************
 *                  MSG_META_LOST_FOCUS_EXCL

 *                  for LadderApplicationClass
 ***********************************************************************
 * SYNOPSIS:        Handle lost of focus of the application object.
 * CALLED BY:       Internal
 * PARAMETERS:      void ( )
 * RETURN:          nothing
 * SIDE EFFECTS:    none
 *

 * STRATEGY:        1/ Send a message to the process that we lost the
 *                     focus and save the state in a global variable.
 *                  2/ Call super for default actions.
 *
 * REVISION HISTORY:
 *      Name    Date          Description
 *      ----    ----          -----------
 *      boa     2024-07-16    Initial Revision
 *
 ***********************************************************************/
@method LadderApplicationClass, MSG_META_LOST_FOCUS_EXCL
{
  // Inform process about window lost focus
  @send process::MSG_LAD_EXEC_SET_FLAGS(EXE_F_LOST);
  // Do super
  @callsuper();
}

/***********************************************************************
 *                  MSG_META_GAINED_FOCUS_EXCL
 *                  for LadderApplicationClass
 ***********************************************************************
 * SYNOPSIS:        Handle gain of focus of the application object.
 * CALLED BY:       Internal
 * PARAMETERS:      void ( )
 * RETURN:          nothing
 * SIDE EFFECTS:    none
 *
 * STRATEGY:        1/ Send a message to the process that we gained the
 *                     focus and save the state in a global variable.
 *                  2/ Call super for default actions.
 *
 * REVISION HISTORY:
 *      Name    Date          Description
 *      ----    ----          -----------
 *      boa     2024-07-16    Initial Revision
 *
 ***********************************************************************/
@method LadderApplicationClass, MSG_META_GAINED_FOCUS_EXCL
{
  // Inform process about window gained focus
  @send process::MSG_LAD_EXEC_SET_FLAGS(EXE_F_GAIN);
  // Do super
  @callsuper();
}


/* End of 'process.goc' */
